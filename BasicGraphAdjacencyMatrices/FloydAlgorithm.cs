using System;
using System.Collections.Generic;
using System.Linq;

namespace BasicGraphAdjacencyMatrices
{
    public static class FloydAlgorithm
    {

        /// <summary>
        /// Runs Floyd's Algorithm on an adjacency matrix to get a table for detours and a table for minimum distances
        /// </summary>
        /// <param name="matrix">The matrix to use</param>
        /// <param name="minimumDistances">The table of minimum distances</param>
        /// <returns>A matrix describing the detours that should be used for taking the shortest route to another node</returns>
        public static int[,] Run(AdjacencyMatrix matrix,
            out double[,] minimumDistances)
        {

            #region Initial distance table

            double?[,] rawMinimumDistanceTable = matrix.GetMatrixCopy();
            minimumDistances = new double[matrix.NodeCount, matrix.NodeCount];

            #region Convert no route to maximum distance

            for (int column = 0; column < matrix.NodeCount; column++)
                for (int row = 0; row < matrix.NodeCount; row++)
                    if (rawMinimumDistanceTable[column, row] == null)
                        minimumDistances[column, row] = double.MaxValue;
                    else
                        minimumDistances[column, row] = (double)rawMinimumDistanceTable[column, row];

            #endregion

            #endregion

            #region Initial route table

            int[,] routeTable = new int[matrix.NodeCount, matrix.NodeCount];

            for (int nodeToSetTo = 0; nodeToSetTo < matrix.NodeCount; nodeToSetTo++)
                for (int entry = 0; entry < matrix.NodeCount; entry++)
                    routeTable[nodeToSetTo, entry] = nodeToSetTo;

            #endregion

            #region Table construction

            for (int nodeIteration = 0; nodeIteration < matrix.NodeCount; nodeIteration++)
            {

                for (int column = 0; column < matrix.NodeCount; column++)
                {

                    if (column == nodeIteration)
                        continue;

                    for (int row = 0; row < matrix.NodeCount; row++)
                    {

                        if (row == nodeIteration)
                            continue;

                        if (column == row)
                            continue;

                        double currentDistance = minimumDistances[column, row];
                        double newPossibleSuggestedDistance = minimumDistances[column, nodeIteration] + minimumDistances[nodeIteration, row];

                        if (newPossibleSuggestedDistance < currentDistance)
                        {

                            minimumDistances[column, row] = newPossibleSuggestedDistance;
                            routeTable[column, row] = nodeIteration;

                        }

                    }

                }

            }

            #endregion

            #region Output

            return routeTable;

            #endregion

        }

        /// <summary>
        /// Uses tables generated by Floyd's algorithm to find the shortest route between two nodes and the route's distance
        /// </summary>
        /// <param name="matrix">The matrix to use</param>
        /// <param name="startNode">The node to start at</param>
        /// <param name="endNode">The node to end at</param>
        /// <param name="routeTable">The route table to use</param>
        /// <param name="distanceTable">The distance table to use</param>
        /// <param name="routeDistance">The total distance that the route will take</param>
        /// <returns>The shortest path as an array of nodes</returns>
        public static int[] FindRoute(AdjacencyMatrix matrix,
            int startNode,
            int endNode,
            int[,] routeTable,
            double[,] distanceTable,
            out double routeDistance)
        {

            #region Find Path

            List<int> pathList = new List<int> { startNode, endNode };

            while (true)
            {

                bool routeChanged = false;

                for (int i = 0; i < pathList.Count - 1; i++)
                {

                    int node1 = pathList[i];
                    int node2 = pathList[i + 1];

                    int routeEntry = routeTable[node1, node2];

                    if (routeEntry != node1)
                    {

                        routeChanged = true;
                        pathList.Insert(i + 1, routeEntry);
                        break;

                    }

                }

                if (!routeChanged)
                    break;

            }

            int[] path = pathList.ToArray();

            #endregion

            #region Get Path Distance

            double totalDistance = 0;

            for (int i = 0; i < path.Length - 1; i++)
            {

                totalDistance += distanceTable[
                    path[i],
                    path[i + 1]
                    ];

            }

            #endregion

            routeDistance = totalDistance;
            return path;

        }

        public static int[] FindRoute(AdjacencyMatrix matrix,
            int startNode,
            int endNode,
            out double routeDistance)
        {
            int[,] routeTable = Run(matrix, out double[,] distanceTable);
            return FindRoute(matrix,
                startNode,
                endNode,
                routeTable,
                distanceTable,
                out routeDistance);
        }

        public static int[] FindRoute(AdjacencyMatrix matrix,
            int startNode,
            int endNode,
            int[,] routeTable,
            double[,] distanceTable)
            => FindRoute(matrix,
                startNode,
                endNode,
                routeTable,
                distanceTable,
                out double _);

        public static int[] FindRoute(AdjacencyMatrix matrix,
            int startNode,
            int endNode)
            => FindRoute(matrix, startNode, endNode, out double _);

    }
}
